<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hooks & State Management - Budget Buddy Developer Docs</title>
    <link href="https://fonts.googleapis.com/css2?family=Titillium+Web:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Titillium Web', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #1a1a1a;
            background: #ffffff;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #000;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            color: #000;
        }

        .breadcrumb {
            color: #666;
            margin-bottom: 1rem;
        }

        .breadcrumb a {
            color: #000;
            text-decoration: none;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        h2 {
            font-size: 1.8rem;
            margin: 2rem 0 1rem 0;
            color: #000;
            border-bottom: 1px solid #ccc;
            padding-bottom: 0.5rem;
        }

        h3 {
            font-size: 1.4rem;
            margin: 1.5rem 0 1rem 0;
            color: #000;
        }

        h4 {
            font-size: 1.2rem;
            margin: 1rem 0 0.5rem 0;
            color: #333;
        }

        p {
            margin-bottom: 1rem;
            color: #333;
        }

        pre {
            background: #f8f8f8;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 1rem;
            overflow-x: auto;
            margin: 1rem 0;
            font-size: 0.9rem;
        }

        code {
            background: #f0f0f0;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            font-size: 0.9em;
        }

        pre code {
            background: none;
            padding: 0;
        }

        ul, ol {
            margin: 1rem 0;
            padding-left: 2rem;
        }

        li {
            margin: 0.5rem 0;
        }

        .hook-card {
            background: #f8f8f8;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
        }

        .hook-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .hook-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #000;
        }

        .hook-type {
            background: #000;
            color: #fff;
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .params-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            font-size: 0.9rem;
        }

        .params-table th,
        .params-table td {
            border: 1px solid #ccc;
            padding: 0.6rem;
            text-align: left;
        }

        .params-table th {
            background: #e8e8e8;
            font-weight: 600;
        }

        .warning {
            background: #fff3cd;
            border: 1px solid #ffecb5;
            color: #856404;
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
        }

        .info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
        }

        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
        }

        footer {
            text-align: center;
            padding: 2rem;
            border-top: 2px solid #000;
            margin-top: 3rem;
            color: #666;
        }

        footer a {
            color: #000;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 2rem;
            }

            .hook-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="breadcrumb">
                <a href="./index.html">Developer Docs</a> > Hooks & State Management
            </div>
            <h1>ðŸŽ£ Hooks & State Management</h1>
            <p>Custom hooks, state management patterns, and data flow documentation</p>
        </header>

        <div class="info">
            <strong>State Management Strategy:</strong> Budget Buddy uses React Context for authentication, custom hooks for Firebase data management, and local component state for UI interactions.
        </div>

        <h2>Core Hooks</h2>

        <div class="hook-card">
            <div class="hook-header">
                <div class="hook-title">useFirestoreData</div>
                <div class="hook-type">Data Hook</div>
            </div>
            <p><strong>Location:</strong> <code>src/hooks/useFirestoreData.tsx</code></p>
            <p><strong>Purpose:</strong> Central hook for all Firebase data operations and real-time subscriptions</p>
            
            <h4>Return Values</h4>
            <table class="params-table">
                <thead>
                    <tr>
                        <th>Property</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>expenses</code></td>
                        <td><code>Expense[]</code></td>
                        <td>User's expenses with real-time updates</td>
                    </tr>
                    <tr>
                        <td><code>budgets</code></td>
                        <td><code>Budget[]</code></td>
                        <td>User's budget configurations</td>
                    </tr>
                    <tr>
                        <td><code>templates</code></td>
                        <td><code>RecurringTemplate[]</code></td>
                        <td>Recurring transaction templates</td>
                    </tr>
                    <tr>
                        <td><code>customCategories</code></td>
                        <td><code>CustomCategory[]</code></td>
                        <td>User-created categories</td>
                    </tr>
                    <tr>
                        <td><code>publicCategories</code></td>
                        <td><code>CustomCategory[]</code></td>
                        <td>Shared public categories</td>
                    </tr>
                    <tr>
                        <td><code>customPeople</code></td>
                        <td><code>Person[]</code></td>
                        <td>User's private people data</td>
                    </tr>
                    <tr>
                        <td><code>publicPeople</code></td>
                        <td><code>Person[]</code></td>
                        <td>Shared public people data</td>
                    </tr>
                    <tr>
                        <td><code>budgetTemplates</code></td>
                        <td><code>BudgetTemplate[]</code></td>
                        <td>User's budget templates</td>
                    </tr>
                    <tr>
                        <td><code>publicBudgetTemplates</code></td>
                        <td><code>BudgetTemplate[]</code></td>
                        <td>Shared budget templates</td>
                    </tr>
                    <tr>
                        <td><code>loading</code></td>
                        <td><code>boolean</code></td>
                        <td>Loading state for initial data fetch</td>
                    </tr>
                </tbody>
            </table>

            <h4>Operation Functions</h4>
            <pre><code>// Expense operations - Core CRUD functions for expense management
addExpense: (expense: Omit&lt;Expense, 'id'&gt;) => Promise&lt;void&gt; // Creates new expense
updateExpense: (expenseId: string, updates: Partial&lt;Expense&gt;) => Promise&lt;void&gt; // Updates specific fields
deleteExpense: (expenseId: string, receiptUrl?: string) => Promise&lt;void&gt; // Deletes expense and receipt

// Budget operations - Budget configuration management
addBudget: (budget: Omit&lt;Budget, 'id'&gt;) => Promise&lt;void&gt; // Creates new budget limit
updateBudget: (budgetId: string, updates: Partial&lt;Budget&gt;) => Promise&lt;void&gt; // Updates budget settings
deleteBudget: (budgetId: string) => Promise&lt;void&gt; // Removes budget configuration

// Template operations - Recurring transaction templates
addTemplate: (template: Omit&lt;RecurringTemplate, 'id'&gt;) => Promise&lt;void&gt; // Creates reusable template
deleteTemplate: (templateId: string) => Promise&lt;void&gt; // Removes template

// Category operations - Custom category management
addCustomCategory: (category: Omit&lt;CustomCategory, 'id'&gt;) => Promise&lt;void&gt; // Creates personal category
updateCustomCategory: (categoryId: string, updates: Partial&lt;CustomCategory&gt;) => Promise&lt;void&gt; // Updates category
deleteCustomCategory: (categoryId: string) => Promise&lt;void&gt; // Removes personal category
adoptPublicCategory: (categoryId: string) => Promise&lt;void&gt; // Adopts shared category as personal

// People operations - Person data management for expense sharing
addPerson: (person: Omit&lt;Person, 'id'&gt;) => Promise&lt;void&gt; // Adds new person
updatePerson: (personId: string, updates: Partial&lt;Person&gt;) => Promise&lt;void&gt; // Updates person details
deletePerson: (personId: string) => Promise&lt;void&gt; // Removes person
adoptPublicPerson: (personId: string) => Promise&lt;void&gt; // Adopts shared person as personal

// Budget template operations - Reusable budget configurations
addBudgetTemplate: (template: Omit&lt;BudgetTemplate, 'id'&gt;) => Promise&lt;void&gt; // Creates budget template
updateBudgetTemplate: (templateId: string, updates: Partial&lt;BudgetTemplate&gt;) => Promise&lt;void&gt; // Updates template
deleteBudgetTemplate: (templateId: string) => Promise&lt;void&gt; // Removes template
adoptPublicBudgetTemplate: (templateId: string) => Promise&lt;void&gt; // Adopts shared template</code></pre>

            <h4>Usage Example</h4>
            <pre><code>// Example component using useFirestoreData hook
function ExpenseManager() {
  const {
    expenses, // Real-time expense data array
    budgets, // User's budget configurations
    customCategories, // User's personal categories
    publicCategories, // Shared categories available to all users
    customPeople, // User's personal people data
    publicPeople, // Shared people data
    loading, // Initial data loading state
    addExpense, // Function to create new expense
    updateExpense, // Function to modify existing expense
    deleteExpense // Function to remove expense and associated receipt
  } = useFirestoreData();

  // Handler for adding a new expense with error handling
  const handleAddExpense = async (expenseData: Omit&lt;Expense, 'id'&gt;) => {
    try {
      await addExpense(expenseData); // Calls Firebase to create expense
      toast.success("Expense added successfully");
    } catch (error) {
      console.error('Add expense error:', error);
      toast.error("Failed to add expense");
    }
  };

  // Show loading spinner while initial data loads
  if (loading) {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }

  return (
    &lt;div&gt;
      {/* Component implementation with real-time data */}
    &lt;/div&gt;
  );
}</code></pre>

            <div class="warning">
                <strong>Important:</strong> This hook automatically manages Firebase subscriptions and cleans them up on unmount. Always use the operation functions provided rather than calling Firebase directly.
            </div>
        </div>

        <div class="hook-card">
            <div class="hook-header">
                <div class="hook-title">useAuth</div>
                <div class="hook-type">Context Hook</div>
            </div>
            <p><strong>Location:</strong> <code>src/contexts/AuthContext.tsx</code></p>
            <p><strong>Purpose:</strong> Authentication state management and operations</p>
            
            <h4>Return Values</h4>
            <table class="params-table">
                <thead>
                    <tr>
                        <th>Property</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>user</code></td>
                        <td><code>User | null</code></td>
                        <td>Current authenticated user or null</td>
                    </tr>
                    <tr>
                        <td><code>loading</code></td>
                        <td><code>boolean</code></td>
                        <td>Authentication loading state</td>
                    </tr>
                    <tr>
                        <td><code>signInWithGoogle</code></td>
                        <td><code>() => Promise&lt;void&gt;</code></td>
                        <td>Google OAuth sign-in function</td>
                    </tr>
                    <tr>
                        <td><code>signOut</code></td>
                        <td><code>() => Promise&lt;void&gt;</code></td>
                        <td>Sign out function</td>
                    </tr>
                </tbody>
            </table>

            <h4>Implementation</h4>
            <pre><code>// AuthContext interface - defines what the context provides
interface AuthContextType {
  user: User | null; // Firebase User object or null if not authenticated
  loading: boolean; // True during auth state initialization
  signInWithGoogle: () => Promise&lt;void&gt;; // Google OAuth sign-in function
  signOut: () => Promise&lt;void&gt;; // Sign out function
}

// AuthProvider component - wraps app to provide auth context
export const AuthProvider: React.FC&lt;{ children: React.ReactNode }&gt; = ({ children }) => {
  const [user, setUser] = useState&lt;User | null&gt;(null); // Current user state
  const [loading, setLoading] = useState(true); // Auth loading state

  // Listen for auth state changes on component mount
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (user) => {
      setUser(user); // Update user state when auth state changes
      setLoading(false); // Auth state has been determined
    });

    return unsubscribe; // Cleanup listener on component unmount
  }, []);

  // Google OAuth sign-in with error handling
  const signInWithGoogle = async () => {
    try {
      setLoading(true); // Show loading during sign-in process
      await signInWithGoogleFirebase(); // Firebase Google auth
    } catch (error) {
      console.error('Sign in error:', error);
      throw error; // Re-throw for component error handling
    } finally {
      setLoading(false); // Hide loading regardless of outcome
    }
  };

  // Sign out with error handling
  const signOut = async () => {
    try {
      await signOutFirebase(); // Firebase sign out
    } catch (error) {
      console.error('Sign out error:', error);
      throw error; // Re-throw for component error handling
    }
  };

  // Context value object
  const value = {
    user,
    loading,
    signInWithGoogle,
    signOut
  };

  return (
    &lt;AuthContext.Provider value={value}&gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  );
};</code></pre>

            <h4>Usage Example</h4>
            <pre><code>// Example authentication component using useAuth hook
function LoginComponent() {
  const { user, loading, signInWithGoogle, signOut } = useAuth();

  // Show loading spinner during auth state initialization
  if (loading) {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }

  // If user is authenticated, show welcome message and sign out option
  if (user) {
    return (
      &lt;div&gt;
        &lt;p&gt;Welcome, {user.displayName}!&lt;/p&gt;
        &lt;button onClick={signOut}&gt;Sign Out&lt;/button&gt;
      &lt;/div&gt;
    );
  }

  // If user is not authenticated, show sign in button
  return (
    &lt;button onClick={signInWithGoogle}&gt;
      Sign In with Google
    &lt;/button&gt;
  );
}</code></pre>
        </div>

        <div class="hook-card">
            <div class="hook-header">
                <div class="hook-title">use-mobile</div>
                <div class="hook-type">Utility Hook</div>
            </div>
            <p><strong>Location:</strong> <code>src/hooks/use-mobile.ts</code></p>
            <p><strong>Purpose:</strong> Responsive design detection for mobile breakpoints</p>
            
            <h4>Implementation</h4>
            <pre><code>// Mobile breakpoint detection hook with window resize listener
import { useState, useEffect } from 'react';

export function useIsMobile() {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    // Function to check if screen width is below mobile breakpoint (768px)
    const checkIsMobile = () => {
      setIsMobile(window.innerWidth < 768); // Tailwind's 'md' breakpoint
    };

    // Check immediately on mount
    checkIsMobile();
    
    // Add resize listener to update on window size change
    window.addEventListener('resize', checkIsMobile);

    // Cleanup listener on component unmount
    return () => {
      window.removeEventListener('resize', checkIsMobile);
    };
  }, []);

  return isMobile; // Returns true if screen width < 768px
}</code></pre>

            <h4>Usage Example</h4>
            <pre><code>// Responsive component that adapts to screen size
function ResponsiveComponent() {
  const isMobile = useIsMobile(); // Get current mobile state

  return (
    &lt;div className={isMobile ? "mobile-layout" : "desktop-layout"}&gt;
      {/* Conditionally render different navigation based on screen size */}
      {isMobile ? &lt;MobileNav /&gt; : &lt;DesktopNav /&gt;}
      
      {/* Different content layouts for mobile vs desktop */}
      &lt;main className={isMobile ? "p-4" : "p-8"}&gt;
        {/* Component content */}
      &lt;/main&gt;
    &lt;/div&gt;
  );
}</code></pre>
        </div>

        <h2>State Management Patterns</h2>

        <div class="hook-card">
            <div class="hook-header">
                <div class="hook-title">Filter State Management</div>
                <div class="hook-type">Pattern</div>
            </div>
            <p><strong>Location:</strong> <code>src/App.tsx</code></p>
            <p><strong>Purpose:</strong> Centralized filter state for expense and budget management</p>
            
            <h4>Filter State Implementation</h4>
            <pre><code>// Main filter states in App component
const [searchTerm, setSearchTerm] = useState('');
const [categoryFilter, setCategoryFilter] = useState('all');
const [peopleFilter, setPeopleFilter] = useState('all');
const [sortBy, setSortBy] = useState&lt;'date' | 'amount' | 'category'&gt;('date');
const [dateRange, setDateRange] = useState&lt;DateRange&gt;({
  from: new Date(new Date().getFullYear(), new Date().getMonth(), 1),
  to: new Date()
});

// Derived filtered data
const filteredExpenses = useMemo(() => {
  let filtered = getExpensesByDateRange(expenses, dateRange);
  
  // Apply search filter
  if (searchTerm) {
    filtered = filtered.filter(expense =>
      expense.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
      expense.category.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }
  
  // Apply category filter
  if (categoryFilter !== 'all') {
    filtered = filtered.filter(expense => expense.category === categoryFilter);
  }
  
  // Apply people filter
  if (peopleFilter !== 'all') {
    filtered = filtered.filter(expense => 
      expense.peopleIds?.includes(peopleFilter)
    );
  }
  
  // Apply sorting
  filtered.sort((a, b) => {
    switch (sortBy) {
      case 'date':
        return new Date(b.date).getTime() - new Date(a.date).getTime();
      case 'amount':
        return b.amount - a.amount;
      case 'category':
        return a.category.localeCompare(b.category);
      default:
        return 0;
    }
  });
  
  return filtered;
}, [expenses, searchTerm, categoryFilter, peopleFilter, sortBy, dateRange]);</code></pre>

            <h4>Filter Components</h4>
            <pre><code>// Filter props pattern
interface FilterProps {
  searchTerm: string;
  onSearchChange: (term: string) => void;
  categoryFilter: string;
  onCategoryChange: (category: string) => void;
  peopleFilter: string;
  onPeopleChange: (personId: string) => void;
  sortBy: 'date' | 'amount' | 'category';
  onSortChange: (sort: 'date' | 'amount' | 'category') => void;
  dateRange: DateRange;
  onDateRangeChange: (range: DateRange) => void;
}</code></pre>
        </div>

        <div class="hook-card">
            <div class="hook-header">
                <div class="hook-title">View Mode Persistence</div>
                <div class="hook-type">Pattern</div>
            </div>
            <p><strong>Purpose:</strong> Persistent view mode state across app sessions</p>
            
            <h4>Implementation</h4>
            <pre><code>// View mode with localStorage persistence
const [viewMode, setViewMode] = useState&lt;'list' | 'grid'&gt;(() => {
  const saved = localStorage.getItem('budget-buddy-view-mode');
  return (saved as 'list' | 'grid') || 'grid';
});

// Persist view mode changes
useEffect(() => {
  localStorage.setItem('budget-buddy-view-mode', viewMode);
}, [viewMode]);

// View mode toggle function
const toggleViewMode = () => {
  setViewMode(current => current === 'grid' ? 'list' : 'grid');
};</code></pre>

            <h4>Component Integration</h4>
            <pre><code>// Pass view mode to components
&lt;ExpenseList 
  expenses={filteredExpenses}
  viewMode={viewMode}
  onToggleViewMode={toggleViewMode}
  // ... other props
/&gt;

// Conditional rendering based on view mode
&lt;div className={
  viewMode === 'grid' 
    ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"
    : "space-y-4"
}&gt;
  {expenses.map(expense => (
    &lt;ExpenseCard 
      key={expense.id}
      expense={expense}
      viewMode={viewMode}
      // ... other props
    /&gt;
  ))}
&lt;/div&gt;</code></pre>
        </div>

        <h2>Custom Hook Patterns</h2>

        <div class="hook-card">
            <div class="hook-header">
                <div class="hook-title">useLocalStorage</div>
                <div class="hook-type">Utility Hook</div>
            </div>
            <p><strong>Purpose:</strong> Generic localStorage hook with type safety</p>
            
            <h4>Implementation</h4>
            <pre><code>import { useState, useEffect } from 'react';

function useLocalStorage&lt;T&gt;(
  key: string, 
  initialValue: T
): [T, (value: T | ((val: T) => T)) => void] {
  // State to store our value
  const [storedValue, setStoredValue] = useState&lt;T&gt;(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Return a wrapped version of useState's setter function that persists the new value to localStorage
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      // Allow value to be a function so we have the same API as useState
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue];
}</code></pre>

            <h4>Usage Example</h4>
            <pre><code>function PreferencesComponent() {
  const [theme, setTheme] = useLocalStorage&lt;'light' | 'dark'&gt;('theme', 'light');
  const [language, setLanguage] = useLocalStorage&lt;string&gt;('language', 'en');
  
  return (
    &lt;div&gt;
      &lt;select value={theme} onChange={(e) => setTheme(e.target.value as 'light' | 'dark')}&gt;
        &lt;option value="light"&gt;Light&lt;/option&gt;
        &lt;option value="dark"&gt;Dark&lt;/option&gt;
      &lt;/select&gt;
    &lt;/div&gt;
  );
}</code></pre>
        </div>

        <div class="hook-card">
            <div class="hook-header">
                <div class="hook-title">useDebounce</div>
                <div class="hook-type">Performance Hook</div>
            </div>
            <p><strong>Purpose:</strong> Debounce values for search and API calls</p>
            
            <h4>Implementation</h4>
            <pre><code>import { useState, useEffect } from 'react';

function useDebounce&lt;T&gt;(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState&lt;T&gt;(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}</code></pre>

            <h4>Usage Example</h4>
            <pre><code>function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 300);

  useEffect(() => {
    if (debouncedSearchTerm) {
      // Perform search operation
      performSearch(debouncedSearchTerm);
    }
  }, [debouncedSearchTerm]);

  return (
    &lt;input
      type="text"
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
      placeholder="Search expenses..."
    /&gt;
  );
}</code></pre>
        </div>

        <h2>Data Flow Architecture</h2>

        <div class="success">
            <h3>Data Flow Summary</h3>
            <ol>
                <li><strong>Authentication:</strong> <code>AuthContext</code> manages user state</li>
                <li><strong>Data Fetching:</strong> <code>useFirestoreData</code> provides real-time Firebase data</li>
                <li><strong>Component State:</strong> Local state for UI interactions and forms</li>
                <li><strong>Filters:</strong> Centralized filter state in App component</li>
                <li><strong>Persistence:</strong> localStorage for user preferences</li>
                <li><strong>Operations:</strong> Firebase operations through provided hook functions</li>
            </ol>
        </div>

        <div class="warning">
            <strong>Best Practices:</strong>
            <ul>
                <li>Always use provided hook functions for Firebase operations</li>
                <li>Implement proper loading and error states</li>
                <li>Use useMemo for expensive calculations</li>
                <li>Debounce search inputs and API calls</li>
                <li>Clean up subscriptions and timeouts</li>
                <li>Handle offline scenarios gracefully</li>
            </ul>
        </div>

        <footer>
            <p>&copy; 2025 Budget Buddy Developer Documentation | 
               <a href="./index.html">Back to Index</a> | 
               <a href="./components.html">Components</a> |
               <a href="./firebase.html">Firebase</a>
            </p>
            <p>Last Updated: August 23, 2025 | Version 2.5.5</p>
        </footer>
    </div>
</body>
</html>
