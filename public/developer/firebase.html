<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firebase Integration - FinBuddy Developer Docs</title>
    <link href="https://fonts.googleapis.com/css2?family=Titillium+Web:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Titillium Web', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #1a1a1a;
            background: #ffffff;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #000;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            color: #000;
        }

        .breadcrumb {
            color: #666;
            margin-bottom: 1rem;
        }

        .breadcrumb a {
            color: #000;
            text-decoration: none;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        h2 {
            font-size: 1.8rem;
            margin: 2rem 0 1rem 0;
            color: #000;
            border-bottom: 1px solid #ccc;
            padding-bottom: 0.5rem;
        }

        h3 {
            font-size: 1.4rem;
            margin: 1.5rem 0 1rem 0;
            color: #000;
        }

        h4 {
            font-size: 1.2rem;
            margin: 1rem 0 0.5rem 0;
            color: #333;
        }

        p {
            margin-bottom: 1rem;
            color: #333;
        }

        pre {
            background: #f8f8f8;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 1rem;
            overflow-x: auto;
            margin: 1rem 0;
            font-size: 0.9rem;
        }

        code {
            background: #f0f0f0;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            font-size: 0.9em;
        }

        pre code {
            background: none;
            padding: 0;
        }

        ul, ol {
            margin: 1rem 0;
            padding-left: 2rem;
        }

        li {
            margin: 0.5rem 0;
        }

        .section-card {
            background: #f8f8f8;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
        }

        .warning {
            background: #fff3cd;
            border: 1px solid #ffecb5;
            color: #856404;
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
        }

        .info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
        }

        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        th, td {
            border: 1px solid #ccc;
            padding: 0.8rem;
            text-align: left;
        }

        th {
            background: #f8f8f8;
            font-weight: 600;
        }

        .db-structure {
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            font-size: 0.9rem;
            background: #f8f8f8;
            border: 1px solid #ccc;
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
        }

        .db-structure ul {
            list-style: none;
            padding-left: 1rem;
        }

        .db-structure li {
            margin: 0.2rem 0;
        }

        .collection {
            font-weight: bold;
            color: #000;
        }

        .document {
            color: #666;
        }

        footer {
            text-align: center;
            padding: 2rem;
            border-top: 2px solid #000;
            margin-top: 3rem;
            color: #666;
        }

        footer a {
            color: #000;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 2rem;
            }

            pre {
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="breadcrumb">
                <a href="./index.html">Developer Docs</a> > Firebase Integration
            </div>
            <h1>ðŸ”¥ Firebase Integration</h1>
            <p>Complete Firebase setup, configuration, and usage patterns for FinBuddy</p>
        </header>

        <div class="info">
            <strong>Firebase Services Used:</strong> Authentication (Google OAuth), Firestore Database, Cloud Storage, and Security Rules for data protection and user isolation.
        </div>

        <h2>Firebase Configuration</h2>

        <div class="section-card">
            <h3>Configuration Setup</h3>
            <p><strong>Location:</strong> <code>src/lib/firebase.ts</code></p>
            
            <pre><code>// Firebase configuration object - Replace with your project details
const firebaseConfig = {
  apiKey: "your-api-key",                    // Public API key for client-side requests
  authDomain: "your-project.firebaseapp.com", // Domain for authentication
  projectId: "your-project-id",              // Unique identifier for Firestore
  storageBucket: "your-project.appspot.com", // Cloud Storage bucket URL
  messagingSenderId: "123456789",            // For push notifications (optional)
  appId: "your-app-id",                      // Unique app identifier
  measurementId: "your-measurement-id"       // For Google Analytics (optional)
};

// Initialize Firebase services - These exports are used throughout the app
const app = initializeApp(firebaseConfig);
export const auth = getAuth(app);    // Authentication service
export const db = getFirestore(app); // Firestore database service
export const storage = getStorage(app); // Cloud Storage service</code></pre>

            <h4>Environment Setup</h4>
            <ol>
                <li>Create Firebase project in <a href="https://console.firebase.google.com/">Firebase Console</a></li>
                <li>Enable Authentication with Google provider</li>
                <li>Create Firestore Database in production mode</li>
                <li>Set up Cloud Storage bucket</li>
                <li>Configure authorized domains for your deployment</li>
            </ol>
        </div>

        <h2>Database Structure</h2>

        <div class="db-structure">
Firestore Collections:
<ul class="collection">users/
  <ul class="document">{userId}/
    <ul class="collection">expenses/
      <li class="document">{expenseId} - Individual expense documents</li>
    </ul>
    <ul class="collection">budgets/
      <li class="document">{budgetId} - Budget limit and tracking</li>
    </ul>
    <ul class="collection">templates/
      <li class="document">{templateId} - Recurring transaction templates</li>
    </ul>
    <ul class="collection">budgetTemplates/
      <li class="document">{templateId} - Budget templates</li>
    </ul>
  </ul>
</ul>

<ul class="collection">Global Collections:
  <ul class="collection">customCategories/
    <li class="document">{categoryId} - User-created categories</li>
  </ul>
  <ul class="collection">publicCategories/
    <li class="document">{categoryId} - Shared categories</li>
  </ul>
  <ul class="collection">publicPeople/
    <li class="document">{personId} - Shared people data</li>
  </ul>
  <ul class="collection">budgetTemplates/
    <li class="document">{templateId} - Shared budget templates</li>
  </ul>
</ul>
        </div>

        <h3>Document Schemas</h3>

        <div class="section-card">
            <h4>Expense Document</h4>
            <pre><code>interface Expense {
  id: string;                    // Auto-generated document ID
  amount: number;                // Expense amount in currency
  category: string;              // Category name
  description: string;           // Expense description
  date: string;                  // Expense date (YYYY-MM-DD)
  createdAt: string;            // Creation timestamp
  receiptUrl?: string;          // Firebase Storage URL for receipt
  receiptFileName?: string;     // Original filename
  peopleIds?: string[];         // Array of person IDs for shared expenses
}</code></pre>

            <h4>Budget Document</h4>
            <pre><code>interface Budget {
  id: string;                   // Auto-generated document ID
  category: string;             // Category this budget applies to
  limit: number;               // Budget limit amount
  spent: number;               // Currently spent amount (calculated)
}</code></pre>

            <h4>Person Document</h4>
            <pre><code>interface Person {
  id: string;                   // Auto-generated document ID
  name: string;                 // Person's name
  color: string;               // Color for UI representation
  icon: string;                // Icon identifier
  userId: string;              // Creator's user ID
  isPublic: boolean;           // Whether shared publicly
  createdAt: string;           // Creation timestamp
  createdBy: string;           // Creator's display name
  relationship?: string;       // Family, Friend, Colleague, etc.
}</code></pre>
        </div>

        <h2>Authentication System</h2>

        <div class="section-card">
            <h3>Google OAuth Integration</h3>
            <pre><code>// Google Auth Provider configuration - Ensures optimal sign-in experience
const googleProvider = new GoogleAuthProvider();
googleProvider.addScope('email');    // Request access to user's email
googleProvider.addScope('profile');  // Request access to basic profile info
googleProvider.setCustomParameters({
  prompt: 'select_account'  // Always show account picker for better UX
});

// Sign in function - Handles popup-based Google authentication
export const signInWithGoogle = async (): Promise&lt;User | null&gt; => {
  try {
    const result = await signInWithPopup(auth, googleProvider);
    // result.user contains user information (email, name, photo, etc.)
    return result.user;
  } catch (error) {
    console.error('Google sign-in error:', error);
    // Handle specific error codes (popup blocked, network issues, etc.)
    throw error;
  }
};</code></pre>

            <h3>AuthContext Implementation</h3>
            <p><strong>Location:</strong> <code>src/contexts/AuthContext.tsx</code></p>
            
            <pre><code>// AuthContext interface - Centralized authentication state management
interface AuthContextType {
  user: User | null;        // Firebase User object or null when not authenticated
  loading: boolean;         // True while checking authentication state
  signInWithGoogle: () => Promise&lt;void&gt;; // Google OAuth sign-in function
  signOut: () => Promise&lt;void&gt;;          // Sign out function
}

// AuthProvider component - Wraps app to provide authentication context
export const AuthProvider: React.FC&lt;{ children: React.ReactNode }&gt; = ({ children }) => {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  const [loading, setLoading] = useState(true); // Start as loading

  useEffect(() => {
    // Listen for authentication state changes
    const unsubscribe = onAuthStateChanged(auth, (user) => {
      setUser(user);          // Update user state
      setLoading(false);      // Authentication check complete
    });

    // Cleanup listener when component unmounts
    return unsubscribe;
  }, []);

  // Provide authentication state and functions to child components
  // Context prevents prop drilling and ensures consistent auth state
};</code></pre>
        </div>

        <h2>Data Operations</h2>

        <div class="section-card">
            <h3>Expense Operations</h3>
            
            <h4>Add Expense</h4>
            <pre><code>// Add new expense to user's private collection
export const addExpenseToFirestore = async (
  userId: string,                    // User's unique ID for data isolation
  expense: Omit&lt;Expense, 'id'&gt;      // Expense data without Firestore-generated ID
): Promise&lt;void&gt; => {
  try {
    // Reference to user's expenses collection
    const expensesRef = collection(db, 'users', userId, 'expenses');
    
    // Add document with auto-generated ID
    await addDoc(expensesRef, {
      ...expense,
      createdAt: new Date().toISOString() // Add server timestamp
    });
    
    // Document automatically gets unique ID and triggers real-time listeners
  } catch (error) {
    console.error('Error adding expense:', error);
    throw error; // Re-throw for component error handling
  }
};</code></pre>

            <h4>Real-time Subscriptions</h4>
            <pre><code>// Subscribe to real-time updates for user's expenses
export const subscribeToExpenses = (
  userId: string,                           // User ID for data isolation
  callback: (expenses: Expense[]) => void  // Function called when data changes
): Unsubscribe => {                        // Returns function to stop listening
  
  const expensesRef = collection(db, 'users', userId, 'expenses');
  
  // Query with ordering - most recent expenses first
  const expensesQuery = query(expensesRef, orderBy('date', 'desc'));

  // Set up real-time listener - triggers callback on any change
  return onSnapshot(expensesQuery, (snapshot) => {
    // Transform Firestore documents to typed expense objects
    const expenses = snapshot.docs.map(doc => ({
      id: doc.id,           // Include document ID
      ...doc.data()         // Spread document data
    })) as Expense[];
    
    callback(expenses);     // Update component state
  }, (error) => {
    console.error('Expenses subscription error:', error);
    // Error handling - subscription continues unless unsubscribed
  });
};</code></pre>

            <h4>Update Expense</h4>
            <pre><code>// Update specific fields of an existing expense
export const updateExpenseInFirestore = async (
  userId: string,                      // User ID for security
  expenseId: string,                   // Document ID to update
  updates: Partial&lt;Expense&gt;           // Only fields that changed
): Promise&lt;void&gt; => {
  try {
    // Reference to specific expense document
    const expenseRef = doc(db, 'users', userId, 'expenses', expenseId);
    
    // Update only provided fields, leave others unchanged
    await updateDoc(expenseRef, updates);
    
    // Real-time listeners automatically receive updated data
  } catch (error) {
    console.error('Error updating expense:', error);
    throw error;
  }
};</code></pre>

            <h4>Delete Expense</h4>
            <pre><code>// Delete expense and associated receipt file
export const deleteExpenseFromFirestore = async (
  userId: string,                    // User ID for security
  expenseId: string,                 // Document ID to delete
  receiptUrl?: string               // Optional receipt URL for cleanup
): Promise&lt;void&gt; => {
  try {
    // Delete the Firestore document
    const expenseRef = doc(db, 'users', userId, 'expenses', expenseId);
    await deleteDoc(expenseRef);

    // Clean up associated receipt file if it exists
    if (receiptUrl) {
      const receiptRef = ref(storage, receiptUrl);
      // Use catch to avoid throwing if file doesn't exist
      await deleteObject(receiptRef).catch(console.warn);
    }
    
    // Real-time listeners automatically remove from UI
  } catch (error) {
    console.error('Error deleting expense:', error);
    throw error;
  }
};</code></pre>
        </div>

        <h2>Cloud Storage Integration</h2>

        <div class="section-card">
            <h3>Receipt Upload System</h3>
            
            <h4>Upload Receipt</h4>
            <pre><code>// Upload receipt image to Cloud Storage and return download URL
export const uploadReceipt = async (
  userId: string,                    // User ID for organized storage structure
  file: File                         // File object from HTML input or drag-drop
): Promise&lt;{ url: string; fileName: string }&gt; => {
  try {
    // Generate unique filename to prevent conflicts
    const timestamp = Date.now();
    const fileName = `${timestamp}_${file.name}`;
    
    // Create reference in user-specific folder
    const receiptRef = ref(storage, `receipts/${userId}/${fileName}`);

    // Upload file to Cloud Storage
    const snapshot = await uploadBytes(receiptRef, file);
    
    // Get public download URL for storing in Firestore
    const downloadUrl = await getDownloadURL(snapshot.ref);

    return {
      url: downloadUrl,        // Store this URL in expense document
      fileName: file.name      // Original filename for display
    };
  } catch (error) {
    console.error('Receipt upload error:', error);
    throw error;
  }
};</code></pre>

            <h4>File Size and Type Validation</h4>
            <pre><code>// Validate uploaded files before sending to Cloud Storage
const validateReceiptFile = (file: File): boolean => {
  const maxSize = 10 * 1024 * 1024; // 10MB limit to control storage costs
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];

  // Check file size to prevent large uploads
  if (file.size > maxSize) {
    throw new Error('File size must be less than 10MB');
  }

  // Ensure only image files are uploaded for security
  if (!allowedTypes.includes(file.type)) {
    throw new Error('Only image files are allowed');
  }

  return true; // File passes validation
};

// Usage in upload component:
// validateReceiptFile(file) before calling uploadReceipt()</code></pre>
        </div>

        <h2>Security Rules</h2>

        <div class="section-card">
            <h3>Firestore Security Rules</h3>
            <p><strong>Location:</strong> <code>firestore.rules</code></p>
            
            <pre><code>rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // User-specific data - complete isolation
    match /users/{userId}/{document=**} {
      allow read, write: if request.auth != null && 
        request.auth.uid == userId;
    }
    
    // Custom categories - user-specific with public sharing
    match /customCategories/{document} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && (
        resource == null || // New documents
        resource.data.userId == request.auth.uid // Creator only
      );
    }
    
    // Public categories - readable by all authenticated users
    match /publicCategories/{document} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && (
        resource == null || // New documents
        resource.data.createdBy == request.auth.uid // Creator only
      );
    }
    
    // Public people - readable by all authenticated users
    match /publicPeople/{document} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && (
        resource == null || // New documents
        resource.data.createdBy == request.auth.uid // Creator only
      );
    }
    
    // Budget templates - readable by all authenticated users
    match /budgetTemplates/{document} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && (
        resource == null || // New documents
        resource.data.userId == request.auth.uid // Creator only
      );
    }
  }
}</code></pre>

            <h3>Storage Security Rules</h3>
            <p><strong>Location:</strong> <code>storage.rules</code></p>
            
            <pre><code>rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    // User's private receipts - only accessible by the user
    match /receipts/{userId}/{receiptId} {
      allow read, write: if request.auth != null && 
        request.auth.uid == userId &&
        // Limit file size to 10MB
        request.resource.size < 10 * 1024 * 1024 &&
        // Only allow image files
        request.resource.contentType.matches('image/.*');
    }
    
    // General user files
    match /users/{userId}/{allPaths=**} {
      allow read, write: if request.auth != null && 
        request.auth.uid == userId &&
        request.resource.size < 10 * 1024 * 1024;
    }
  }
}</code></pre>
        </div>

        <h2>ðŸ¤– KautilyaAI Co-Pilot Integration (v2.6.0)</h2>

        <div class="section-card">
            <h3>Firebase Functions v2 Backend</h3>
            <p><strong>Location:</strong> <code>functions/src/index.ts</code></p>
            
            <p>The KautilyaAI Co-Pilot system uses Firebase Functions v2 to process natural language commands and perform comprehensive CRUD operations across all FinBuddy data types.</p>

            <h4>Function Definition</h4>
            <pre><code>// Firebase Functions v2 with CORS and enhanced error handling
export const chatWithGemini = onRequest(
  {
    cors: true,                    // Enable cross-origin requests
    timeoutSeconds: 60,           // Extended timeout for AI processing
    memory: "1GiB",               // Increased memory for complex operations
    region: "us-central1"         // Optimal region for performance
  },
  async (request: Request, response: Response) => {
    try {
      // CORS headers for client compatibility
      response.set("Access-Control-Allow-Origin", "*");
      response.set("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
      response.set("Access-Control-Allow-Headers", "Content-Type, Authorization");

      if (request.method === "OPTIONS") {
        response.status(200).send();
        return;
      }

      // Extract conversation data and user context
      const { message, conversationId, userId, userContext } = request.body;
      
      // Process with enhanced parseAndExecuteActions
      const result = await parseAndExecuteActions(
        message, conversationId, userId, userContext
      );
      
      response.status(200).json({ 
        response: result.response,
        executedActions: result.executedActions 
      });
    } catch (error) {
      console.error("Chat function error:", error);
      response.status(500).json({ error: "Internal server error" });
    }
  }
);</code></pre>

            <h4>Enhanced CRUD Processing</h4>
            <pre><code>// Comprehensive natural language processing with 20+ regex patterns
async function parseAndExecuteActions(
  message: string,
  conversationId: string,
  userId: string,
  userContext: any
): Promise&lt;{ response: string; executedActions: any }&gt; {
  
  const executedActions: any = {};
  let processedMessage = message.toLowerCase();

  // Enhanced category detection with fuzzy matching
  const categoryPatterns = [
    /(?:add|create|new).*?(?:category|cat).*?(?:called|named|for)\s*["']?([^"'\n]+)["']?/i,
    /(?:category|cat).*?["']([^"']+)["']/i,
    /for\s+([a-zA-Z\s]+?)(?:\s+category)?(?:\s|$)/i,
    /in\s+([a-zA-Z\s]+?)(?:\s+category)?(?:\s|$)/i,
    // ... 16+ more sophisticated patterns
  ];

  // Smart category mapping with common variations
  const categoryMapping: { [key: string]: string } = {
    "food": "Food & Dining",
    "transport": "Transportation", 
    "education": "Education",
    "entertainment": "Entertainment",
    "health": "Healthcare",
    // ... comprehensive category mappings
  };

  // Context-aware conversation memory
  if (!conversationMemory.has(conversationId)) {
    conversationMemory.set(conversationId, {
      recentExpenses: [],
      recentBudgets: [],
      recentCategories: [],
      lastOperations: []
    });
  }

  // Process expense operations
  const expenseMatch = processedMessage.match(/add.*?â‚¹?(\d+(?:\.\d{2})?).*?(?:for|in)\s+(.+?)(?:\s|$)/i);
  if (expenseMatch) {
    const amount = parseFloat(expenseMatch[1]);
    let category = expenseMatch[2]?.trim();
    
    // Smart category detection and creation
    category = categoryMapping[category.toLowerCase()] || 
               category.charAt(0).toUpperCase() + category.slice(1);

    const expense = {
      amount,
      category,
      description: `${category} expense`,
      date: new Date().toISOString().split('T')[0],
      createdAt: new Date().toISOString()
    };

    // Add to Firebase and update memory
    await addExpenseToFirestore(userId, expense);
    executedActions.addedExpense = expense;
    
    // Update conversation memory
    const memory = conversationMemory.get(conversationId);
    memory.recentExpenses.unshift({ ...expense, id: 'temp-id' });
    if (memory.recentExpenses.length > 10) memory.recentExpenses.pop();
  }

  // Enhanced deletion with context awareness
  const deleteMatch = processedMessage.match(/delete.*?(?:last|recent)?\s*(.+?)(?:\s+expense)?/i);
  if (deleteMatch) {
    const memory = conversationMemory.get(conversationId);
    const recentExpenses = memory?.recentExpenses || [];
    
    if (recentExpenses.length > 0) {
      const expenseToDelete = recentExpenses[0];
      await deleteExpenseFromFirestore(userId, expenseToDelete.id);
      executedActions.deletedExpense = expenseToDelete;
      memory.recentExpenses.shift(); // Remove from memory
    }
  }

  // Template operations with comprehensive update support
  const templateUpdateMatch = processedMessage.match(/update.*?template.*?(title|name|amount).*?to\s+(.+)/i);
  if (templateUpdateMatch) {
    const field = templateUpdateMatch[1].toLowerCase();
    const newValue = templateUpdateMatch[2].trim();
    
    // Process template updates based on field type
    if (field === 'amount') {
      const amount = parseFloat(newValue.replace(/[â‚¹,]/g, ''));
      executedActions.updatedTemplate = { field, value: amount };
    } else {
      executedActions.updatedTemplate = { field, value: newValue };
    }
  }

  // Generate contextual AI response using Gemini 2.0 Flash
  const response = await generateGeminiResponse(message, executedActions, userContext);
  
  return { response, executedActions };
}</code></pre>

            <h3>Frontend Integration Pipeline</h3>
            <p><strong>Location:</strong> <code>src/components/GeminiChat.tsx</code></p>

            <h4>ExecutedActions Processing</h4>
            <pre><code>// Comprehensive frontend callback execution for real-time UI updates
const handleExecutedActions = async (executedActions: any) => {
  try {
    // Expense operations with immediate UI synchronization
    if (executedActions.addedExpense) {
      await onAddExpense(executedActions.addedExpense);
      toast.success(`Added expense: â‚¹${executedActions.addedExpense.amount} for ${executedActions.addedExpense.category}`);
    }

    if (executedActions.updatedExpense) {
      await onUpdateExpense(executedActions.updatedExpense.id, executedActions.updatedExpense.updates);
      toast.success("Expense updated successfully");
    }

    if (executedActions.deletedExpense) {
      await onDeleteExpense(executedActions.deletedExpense.id);
      toast.success("Expense deleted successfully");
    }

    // Category operations with instant UI reflection
    if (executedActions.addedCategory) {
      await onAddCategory(executedActions.addedCategory);
      toast.success(`Created category: ${executedActions.addedCategory.name}`);
    }

    if (executedActions.deletedCategory) {
      await onDeleteCategory(executedActions.deletedCategory.id);
      toast.success("Category deleted successfully");
    }

    // Budget operations with real-time updates
    if (executedActions.addedBudget) {
      await onAddBudget(executedActions.addedBudget);
      toast.success(`Created budget: â‚¹${executedActions.addedBudget.limit} for ${executedActions.addedBudget.category}`);
    }

    if (executedActions.updatedBudget) {
      await onUpdateBudget(executedActions.updatedBudget.id, executedActions.updatedBudget.updates);
      toast.success("Budget updated successfully");
    }

    // People and template operations
    if (executedActions.addedPerson) {
      await onAddPerson(executedActions.addedPerson);
      toast.success(`Added person: ${executedActions.addedPerson.name}`);
    }

    if (executedActions.addedTemplate) {
      await onAddTemplate(executedActions.addedTemplate);
      toast.success(`Created template: ${executedActions.addedTemplate.description}`);
    }

    if (executedActions.updatedTemplate) {
      const { field, value } = executedActions.updatedTemplate;
      toast.success(`Updated template ${field} to: ${value}`);
    }

  } catch (error) {
    console.error('Error executing actions:', error);
    toast.error('Failed to execute some operations');
  }
};</code></pre>

            <h4>Chat Interface Integration</h4>
            <pre><code>// Complete CRUD callback props for comprehensive data management
interface GeminiChatProps {
  onAddExpense: (expense: Omit&lt;Expense, 'id'&gt;) => Promise&lt;void&gt;;
  onUpdateExpense: (id: string, updates: Partial&lt;Expense&gt;) => Promise&lt;void&gt;;
  onDeleteExpense: (id: string) => Promise&lt;void&gt;;
  onAddBudget: (budget: Omit&lt;Budget, 'id'&gt;) => Promise&lt;void&gt;;
  onUpdateBudget: (id: string, updates: Partial&lt;Budget&gt;) => Promise&lt;void&gt;;
  onDeleteBudget: (id: string) => Promise&lt;void&gt;;
  onAddCategory: (category: Omit&lt;CustomCategory, 'id'&gt;) => Promise&lt;void&gt;;
  onDeleteCategory: (id: string) => Promise&lt;void&gt;;
  onAddPerson: (person: Omit&lt;Person, 'id'&gt;) => Promise&lt;void&gt;;
  onUpdatePerson: (id: string, updates: Partial&lt;Person&gt;) => Promise&lt;void&gt;;
  onDeletePerson: (id: string) => Promise&lt;void&gt;;
  onAddTemplate: (template: Omit&lt;RecurringTemplate, 'id'&gt;) => Promise&lt;void&gt;;
  onDeleteTemplate: (id: string) => Promise&lt;void&gt;;
  userContext?: {
    expenses: Expense[];
    budgets: Budget[];
    categories: CustomCategory[];
    people: Person[];
    templates: RecurringTemplate[];
  };
}</code></pre>
        </div>

        <h2>Data Management Hook</h2>

        <div class="section-card">
            <h3>useFirestoreData Hook</h3>
            <p><strong>Location:</strong> <code>src/hooks/useFirestoreData.tsx</code></p>
            
            <pre><code>export function useFirestoreData() {
  const { user } = useAuth();
  
  // State for all data types
  const [expenses, setExpenses] = useState&lt;Expense[]&gt;([]);
  const [budgets, setBudgets] = useState&lt;Budget[]&gt;([]);
  const [templates, setTemplates] = useState&lt;RecurringTemplate[]&gt;([]);
  const [customCategories, setCustomCategories] = useState&lt;CustomCategory[]&gt;([]);
  const [publicCategories, setPublicCategories] = useState&lt;CustomCategory[]&gt;([]);
  const [customPeople, setCustomPeople] = useState&lt;Person[]&gt;([]);
  const [publicPeople, setPublicPeople] = useState&lt;Person[]&gt;([]);
  const [budgetTemplates, setBudgetTemplates] = useState&lt;BudgetTemplate[]&gt;([]);
  const [publicBudgetTemplates, setPublicBudgetTemplates] = useState&lt;BudgetTemplate[]&gt;([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!user || !user.uid) {
      // Clear all data when user is not authenticated
      setExpenses([]);
      setBudgets([]);
      // ... clear other states
      setLoading(false);
      return;
    }

    // Set up real-time subscriptions
    const unsubscribeFunctions: (() => void)[] = [];

    // Subscribe to expenses
    const unsubscribeExpenses = subscribeToExpenses(user.uid, setExpenses);
    if (unsubscribeExpenses) {
      unsubscribeFunctions.push(unsubscribeExpenses);
    }

    // Subscribe to other collections...

    return () => {
      unsubscribeFunctions.forEach(unsubscribe => unsubscribe());
    };
  }, [user]);

  // Return data and operation functions
  return {
    expenses, budgets, templates,
    customCategories, publicCategories,
    customPeople, publicPeople,
    budgetTemplates, publicBudgetTemplates,
    loading,
    addExpense: (expense: Omit&lt;Expense, 'id'&gt;) => 
      addExpenseToFirestore(user!.uid, expense),
    updateExpense: (expenseId: string, updates: Partial&lt;Expense&gt;) => 
      updateExpenseInFirestore(user!.uid, expenseId, updates),
    deleteExpense: (expenseId: string, receiptUrl?: string) => 
      deleteExpenseFromFirestore(user!.uid, expenseId, receiptUrl),
    // ... other operations
  };
}</code></pre>
        </div>

        <h2>Error Handling</h2>

        <div class="section-card">
            <h3>Firebase Error Patterns</h3>
            
            <pre><code>// Operation with error handling
const performFirebaseOperation = async () => {
  try {
    // Firebase operation
    const result = await addExpenseToFirestore(userId, expense);
    toast.success("Operation completed successfully");
    return result;
  } catch (error: any) {
    // Handle specific Firebase errors
    switch (error.code) {
      case 'permission-denied':
        toast.error("Permission denied. Please check your access.");
        break;
      case 'not-found':
        toast.error("Resource not found.");
        break;
      case 'unavailable':
        toast.error("Service temporarily unavailable. Please try again.");
        break;
      default:
        console.error('Firebase operation failed:', error);
        toast.error("Operation failed. Please try again.");
    }
    throw error;
  }
};</code></pre>

            <h3>Offline Handling</h3>
            <pre><code>// Enable offline persistence
import { enableNetwork, disableNetwork } from 'firebase/firestore';

// Handle connection state
window.addEventListener('online', () => {
  enableNetwork(db).catch(console.error);
});

window.addEventListener('offline', () => {
  disableNetwork(db).catch(console.error);
});</code></pre>
        </div>

        <h2>Performance Optimization</h2>

        <div class="section-card">
            <h3>Query Optimization</h3>
            
            <pre><code>// Efficient queries with proper indexing
const getExpensesByCategory = (userId: string, category: string) => {
  const expensesRef = collection(db, 'users', userId, 'expenses');
  return query(
    expensesRef,
    where('category', '==', category),
    orderBy('date', 'desc'),
    limit(50) // Limit results for performance
  );
};

// Pagination for large datasets
const getExpensesPaginated = (userId: string, lastDoc?: DocumentSnapshot) => {
  const expensesRef = collection(db, 'users', userId, 'expenses');
  let expensesQuery = query(
    expensesRef,
    orderBy('date', 'desc'),
    limit(25)
  );

  if (lastDoc) {
    expensesQuery = query(expensesQuery, startAfter(lastDoc));
  }

  return expensesQuery;
};</code></pre>

            <h3>Batch Operations</h3>
            <pre><code>import { writeBatch } from 'firebase/firestore';

// Batch write for multiple operations
const batchAddExpenses = async (userId: string, expenses: Omit&lt;Expense, 'id'&gt;[]) => {
  const batch = writeBatch(db);
  
  expenses.forEach(expense => {
    const docRef = doc(collection(db, 'users', userId, 'expenses'));
    batch.set(docRef, {
      ...expense,
      createdAt: new Date().toISOString()
    });
  });

  await batch.commit();
};</code></pre>
        </div>

        <h2>ðŸš€ Firebase Functions v2 Integration (v2.6.0)</h2>
        
        <p>FinBuddy v2.6.0 introduces Firebase Functions v2 with enhanced AI Chat capabilities and improved CORS handling.</p>

        <h3>Firebase Functions Setup</h3>
        <div class="code-block">
            <pre><code>// functions/package.json dependencies
{
  "dependencies": {
    "firebase-functions": "^6.0.1",
    "firebase-admin": "^12.0.0",
    "@google-cloud/functions-framework": "^3.1.0",
    "@google/generative-ai": "^0.21.0",
    "cors": "^2.8.5"
  }
}

// functions/src/index.ts - AI Chat Function
import { onRequest } from 'firebase-functions/v2/https';
import { GoogleGenerativeAI } from '@google/generative-ai';
import * as cors from 'cors';

const corsHandler = cors({
  origin: [
    'http://localhost:5000',
    'https://your-domain.com',
    'https://budget-buddy-app.azurewebsites.net'
  ],
  credentials: true,
  methods: ['GET', 'POST', 'OPTIONS']
});

export const chatWithAI = onRequest({
  cors: true,
  region: 'us-central1'
}, async (req, res) => {
  return new Promise((resolve) => {
    corsHandler(req, res, async () => {
      try {
        const { message, expenses, budgets } = req.body;
        
        const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!);
        const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash-exp" });
        
        const prompt = `You are a personal finance assistant for FinBuddy.
        User message: ${message}
        User expenses: ${JSON.stringify(expenses)}
        User budgets: ${JSON.stringify(budgets)}
        
        Provide helpful financial advice and insights.`;
        
        const result = await model.generateContent(prompt);
        const response = result.response.text();
        
        res.json({ response });
        resolve(void 0);
      } catch (error) {
        console.error('AI Chat error:', error);
        res.status(500).json({ error: 'AI chat failed' });
        resolve(void 0);
      }
    });
  });
});</code></pre>
        </div>

        <h3>Environment Configuration</h3>
        <div class="code-block">
            <pre><code># functions/.env
GEMINI_API_KEY=your_gemini_api_key_here

# Firebase CLI setup
firebase functions:config:set gemini.api_key="your_gemini_api_key"

# Deploy functions
firebase deploy --only functions</code></pre>
        </div>

        <h3>Client-Side AI Integration</h3>
        <div class="code-block">
            <pre><code>// src/lib/aiChat.ts
import { httpsCallable } from 'firebase/functions';
import { functions } from './firebase';

const chatWithAI = httpsCallable(functions, 'chatWithAI');

export const sendChatMessage = async (
  message: string,
  expenses: any[],
  budgets: any[]
): Promise<string> => {
  try {
    const result = await chatWithAI({
      message,
      expenses: expenses.slice(-10), // Recent expenses only
      budgets
    });
    
    return (result.data as any).response;
  } catch (error) {
    console.error('AI Chat failed:', error);
    throw new Error('Failed to get AI response');
  }
};

// Usage in components
import { sendChatMessage } from '../lib/aiChat';

const handleSendMessage = async () => {
  try {
    setLoading(true);
    const response = await sendChatMessage(message, expenses, budgets);
    setMessages(prev => [...prev, 
      { role: 'user', content: message },
      { role: 'assistant', content: response }
    ]);
  } catch (error) {
    toast.error('Failed to send message');
  } finally {
    setLoading(false);
  }
};</code></pre>
        </div>

        <h3>Security Rules for AI Features</h3>
        <div class="code-block">
            <pre><code>// firestore.rules - AI chat data
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // AI chat history (user-specific)
    match /users/{userId}/chatHistory/{chatId} {
      allow read, write: if request.auth != null 
        && request.auth.uid == userId;
    }
    
    // AI preferences
    match /users/{userId}/aiPreferences/settings {
      allow read, write: if request.auth != null 
        && request.auth.uid == userId;
    }
  }
}</code></pre>
        </div>

        <div class="warning">
            <strong>v2.6.0 AI Integration Considerations:</strong>
            <ul>
                <li><strong>API Keys:</strong> Keep Gemini API keys secure in Firebase Functions config</li>
                <li><strong>Rate Limiting:</strong> Implement client-side rate limiting for AI requests</li>
                <li><strong>Data Privacy:</strong> Only send necessary financial data to AI services</li>
                <li><strong>Fallback:</strong> Provide graceful degradation when AI services are unavailable</li>
                <li><strong>Cost Management:</strong> Monitor Gemini API usage and set billing alerts</li>
                <li><strong>CORS Configuration:</strong> Ensure proper CORS setup for production domains</li>
            </ul>
        </div>

        <div class="warning">
            <strong>General Firebase Considerations:</strong>
            <ul>
                <li>Always validate user authentication before Firebase operations</li>
                <li>Use security rules to enforce data access patterns</li>
                <li>Implement proper error handling for offline scenarios</li>
                <li>Monitor Firestore usage to avoid excessive reads/writes</li>
                <li>Use real-time subscriptions sparingly to control costs</li>
            </ul>
        </div>

        <footer>
            <p>&copy; 2025 FinBuddy Developer Documentation | 
               <a href="./index.html">Back to Index</a> | 
               <a href="./architecture.html">Architecture</a> |
               <a href="./api-reference.html">API Reference</a>
            </p>
            <p>Last Updated: January 20, 2025 | Version 2.6.0</p>
        </footer>
    </div>
</body>
</html>
